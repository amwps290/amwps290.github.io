---
title: SQLite3 源码分析-内存管理
author: amwps290
date: 2024-11-22 00:00
categories: [SQLITE, 源码分析]
tags: [sqlite]
mermaid: true
---

## 前记

SQLite3 中有比较复杂的内存管理,为 SQLite3 的稳定和高性能提供了保障.
主要参考资料:

1. [官方文档](https://www.sqlite.org/malloc.html)
2. malloc.c, mem2.c

**SQLite3 内存系统的特点**

1. 强大的内存分配失败处理机制
2. 无内存泄露
3. 内存使用限制
4. 可配置的内存分配器
5. 放置崩溃和内存碎片问题
6. 内存使用统计
7. 友好的内存调试功能
8. 尽量减少内存分配

**SQLite3 内存测试**

当使用源代码编译的时候可以加入 `SQLITE_MEMDEBUG` 选项来开启内存调试.可以进行内存检查,检查的功能如下:

1. 边界检查
2. 使用了释放后的内存
3. 释放了不是使用 `malloc` 申请的内存
4. 未初始化的内存

**默认内存分配制**

SQLite3 默认情况下使用的 C 语言默认的 `malloc`,`free`,`realloc` 的这些内存管理接口,当然你也可以使用其他的内存管理,比如 `jemalloc`
.

**旁路内存分配器**

SQLite3 数据库会进行很多小的,短暂的内存分配,这种情况多见于 `sqlite3_prepare_v2` 函数在解析 SQL 语句的时候,在 `sqlite3_step` 执行 vdbe 编码的时候也会有比较小的内存分配.如果这些小的内存分配使用 `malloc` 和 `free` 的话,那么速度会非常的慢.

自 SQLITE3 3.6.1 版本开始,引入了旁路内存分配器(lookaside memory allocator) 减少内存分配负荷，在旁观分配器中，每个数据库连接都会预先分配一大块内存，然后将这一大块内存划分为固定大小的“插槽”，每个插槽的大小约为 100 到 1000 字节，这就是内存池。此后，与数据库连接相关在内存分配，如果不是太大，就会使用其中一个旁观池插槽。而不是调用通用分配器。较大的内存分配还是会通用内存分配器，当查找池插槽都已使用的时候，会使用通用在内存分配器。

由于旁路内存分配在大小总是相同的，因此分配和取消的算法非常快速。无需合并相邻的空闲槽位，也无需搜索特定大小的槽位。每个数据库连接都会维护一个单链在未使用空闲列表。分配请求只需提取该列表在第一个元素。

**双尺寸 lookside**

从 SQLite 3.31 版本开始， lookside 支持两个内存池，每个内存池有不同大小的插槽。小插槽内存使用 128 字节在插槽，大插槽内存池使用 `SQLITE_DBCONFIG_LOOKASIDE` 指定在大小，默认为 1200 字节。

**内存状态**

默认情况下，SQLite 会对内存使用情况进行统计，这些统计数据有助于确定应用程序真正需要多少内存。这些统计数据还可用于高可靠性系统，以确定内存使用量是否接近或超过 `Robson` 证明的限制。从而确定内存分配子系统是否可能崩溃

## 代码分析

### Mem0Global结构体

```c
static SQLITE_WSD struct Mem0Global {
  sqlite3_mutex *mutex;         /* Mutex to serialize access */
  sqlite3_int64 alarmThreshold; /* The soft heap limit */
  sqlite3_int64 hardLimit;      /* The hard upper bound on memory */

  /*
  ** True if heap is nearly "full" where "full" is defined by the
  ** sqlite3_soft_heap_limit() setting.
  */
  int nearlyFull;
} mem0 = { 0, SQLITE_MAX_MEMORY, SQLITE_MAX_MEMORY, 0 };
```

这个结构体中主要定义了四个变量:

1. `mutex` 用于分配和释放内存中进行加锁和解锁
2. `alarmThreshold` 内存分配的一个软限制,当已经分配的内存到了这个限制,就会设置 nearlyfull 的标志
3. `hardLimit` 内存分配硬限制,即 SQLite3 分配的内存无法超出这个限制.
4. 表示当前使用的内存是否已经快到达来软内存限制

同时我们这里也定一个了一个全局的 `mem0` 对象来统计整个应用程序的内存信息

### sqlite3_release_memory

```c
int sqlite3_release_memory(int n){
  UNUSED_PARAMETER(n);
  return 0;
#endif
}
```

这个函数的作用是释放那些当前没有在使用的内存,比如创建的临时表不再使用就可以进行释放,

### sqlite3MallocMutex

```c
/*
** Return the memory allocator mutex. sqlite3_status() needs it.
*/
sqlite3_mutex *sqlite3MallocMutex(void){
  return mem0.mutex;
}
```

这个函数返回了 `mem0` 的一个锁，这个锁在更新内存使用信心的时候，我们会用到

### sqlite3_soft_heap_limit64

```c
sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){
  sqlite3_int64 priorLimit;
  sqlite3_int64 excess;
  sqlite3_int64 nUsed;
#ifndef SQLITE_OMIT_AUTOINIT
  int rc = sqlite3_initialize();
  if( rc ) return -1;
#endif
  sqlite3_mutex_enter(mem0.mutex);
  priorLimit = mem0.alarmThreshold;
  if( n<0 ){
    sqlite3_mutex_leave(mem0.mutex);
    return priorLimit;
  }
  if( mem0.hardLimit>0 && (n>mem0.hardLimit || n==0) ){
    n = mem0.hardLimit;
  }
  mem0.alarmThreshold = n;
  nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
  AtomicStore(&mem0.nearlyFull, n>0 && n<=nUsed);
  sqlite3_mutex_leave(mem0.mutex);
  excess = sqlite3_memory_used() - n;
  if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));
  return priorLimit;
}
void sqlite3_soft_heap_limit(int n){
  if( n<0 ) n = 0;
  sqlite3_soft_heap_limit64(n);
}
```

在这个函数中我们先使用 `sqlite3_initialize` 来进行系统初始化，一般情况下是已经初始化过的，所以这个会是一个 NO-OP 操作。

然后我们使用 `sqlite3_mutex_leave(mem0.mutex)` 来获取锁，保存一下之前的限制，如果 n 小于 0 则直接返回之前的限制，如果 `mem0` 存在一个硬限制的话，并且新的限制大于硬的限制，那么我们就将这个新的限制和原来的硬限制保持一致。

设置软内存限制，然后我们获取一下当前内存的使用量，如果使用量已经到达来软内存限制，则设置 `nearlyFull` 标志，这里使用了一个原子操作。

然后我们释放锁，如果当前使用的量已经超过来软内存限制，则开始释放一些不用的内存。

### sqlite3_hard_heap_limit64

设置硬内存限制，和设置软内存限制类似。

### sqlite3MallocInit

```c
int sqlite3MallocInit(void){
  int rc;
  if( sqlite3GlobalConfig.m.xMalloc==0 ){
    sqlite3MemSetDefault();
  }
  mem0.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);
  if( sqlite3GlobalConfig.pPage==0 || sqlite3GlobalConfig.szPage<512
      || sqlite3GlobalConfig.nPage<=0 ){
    sqlite3GlobalConfig.pPage = 0;
    sqlite3GlobalConfig.szPage = 0;
  }
  rc = sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);
  if( rc!=SQLITE_OK ) memset(&mem0, 0, sizeof(mem0));
  return rc;
}
```

这个函数的作用就是初始化内存分配系统：

1. 如果 `sqlite3GlobalConfig.m.xMalloc` 还没有设置，即还没有初始化，那么我们就使用默认的内存管理函数，即 `malloc`,`free`,`realloc`,`malloc_usable_size` 等等

2. 为 `mem0.mutex` 分配内存

## 后记
