---
title: SQLite3 源码分析-sqlite_schema(sqlite_master) 的创建
author: amwps290
date: 2024-09-26 09:23
categories: [SQLITE,源码分析]
tags: [sqlite]
render_with_liquid: false
---


根据 SQLite3 的[数据格式](https://www.sqlite.org/fileformat.html#b_tree_pages) 我们可以看到，在数据库文件中的第一个页面存在一个名字叫做 `sqlite_schema` 的表,这个表中会记录 sqlite 数据库中所有的表，索引，视图，以及触发器。这个表会在我们第一次对数据库进行操作的时候进行创建。这个表就相当于数据库中的一个元信息表，我们对数据库的任何 DDL(Data Definition Language，数据定义语言) 操作之前，都需要检查一下，这个数据库中是不是已经存在了相同名字的表。具体的函数就是在 `sqlite3ReadSchema`

```c
/*
** This routine is a no-op if the database schema is already initialized.
** Otherwise, the schema is loaded. An error code is returned.
*/
int sqlite3ReadSchema(Parse *pParse){
  int rc = SQLITE_OK;
  sqlite3 *db = pParse->db;
  assert( sqlite3_mutex_held(db->mutex) );
  if( !db->init.busy ){
    rc = sqlite3Init(db, &pParse->zErrMsg);
    if( rc!=SQLITE_OK ){
      pParse->rc = rc;
      pParse->nErr++;
    }else if( db->noSharedCache ){
      db->mDbFlags |= DBFLAG_SchemaKnownOk;
    }
  }
  return rc;
}
```
在这个函数中我们可以看到如果 `db.init.busy` 来判断数据库当前是否在初始化中，如果没有在初始化，那么我们就进行初始化。

```c
/*
** Initialize all database files - the main database file, the file
** used to store temporary tables, and any additional database files
** created using ATTACH statements.  Return a success code.  If an
** error occurs, write an error message into *pzErrMsg.
**
** After a database is initialized, the DB_SchemaLoaded bit is set
** bit is set in the flags field of the Db structure. 
*/
int sqlite3Init(sqlite3 *db, char **pzErrMsg){
  int i, rc;
  int commit_internal = !(db->mDbFlags&DBFLAG_SchemaChange);
  
  assert( sqlite3_mutex_held(db->mutex) );
  assert( sqlite3BtreeHoldsMutex(db->aDb[0].pBt) );
  assert( db->init.busy==0 );
  ENC(db) = SCHEMA_ENC(db);
  assert( db->nDb>0 );
  /* Do the main schema first */
  if( !DbHasProperty(db, 0, DB_SchemaLoaded) ){
    rc = sqlite3InitOne(db, 0, pzErrMsg, 0);
    if( rc ) return rc;
  }
  /* All other schemas after the main schema. The "temp" schema must be last */
  for(i=db->nDb-1; i>0; i--){
    assert( i==1 || sqlite3BtreeHoldsMutex(db->aDb[i].pBt) );
    if( !DbHasProperty(db, i, DB_SchemaLoaded) ){
      rc = sqlite3InitOne(db, i, pzErrMsg, 0);
      if( rc ) return rc;
    }
  }
  if( commit_internal ){
    sqlite3CommitInternalChanges(db);
  }
  return SQLITE_OK;
}
```

在这个函数中，我们看到主要分为两个部分，一个是检查当前数据库是否已经将数据库中的表，索引等信息读取到内存中的哈希表，这个通过 `DB_SchemaLoaded` 来判断。如果不是最新的，我们就通过 `sqlite3InitOne` 来读取。在第二个 for 循环中功能也是一样的，用来读取数据库中的元数据。

<!-- markdownlint-capture -->
<!-- markdownlint-disable -->
> sqlite 中有两个数据库，一个是 main 数据库，用于储存长期数据，一个是 temp 数据库，用于存储一些临时的对象。
{: .prompt-tip }
<!-- markdownlint-restore -->