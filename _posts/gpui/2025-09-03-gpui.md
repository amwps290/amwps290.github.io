---
title: gpui 1
author: amwps290
date: 2025-09-03 00:10:00 +0800
categories: [GPUI]
tags: [rust,gpui,gpui-compoent]
render_with_liquid: false
---

最近打算开始将学过的 Rust 语言使用起来，就选择了 GPUI 这一个 GUI 的框架，然后使用  gpui-compoent 这个库来提供组件，目的是为了实现一个类似于 DBeaver 的数据库客户端的工具，先从支持 PostgreSQL 开始，今天我们现在学习如何去创建一个窗口；

因为目前 GPUI 和 gpui-compoent 都没有正式的 crate,因此我们只能通过 git 的方式来添加依赖。

```yaml
[package]
name = "rbeaver"
version = "0.1.0"
edition = "2024"

[dependencies]
gpui = { git = "https://github.com/zed-industries/zed.git" }
gpui-component = { git = "https://github.com/longbridge/gpui-component.git" }

```

根据 [gpui](https://github.com/zed-industries/zed/tree/main/crates/gpui) 仓库的说明，我们每一个 GPUI 的程序都应该从一个 `Application` 开始。

我们可以通过 `Applicatoin::new()` 来创建一个 `Application` 对象，然后我们可以调用 `Application::run()` 来运行一个窗口，在 `run` 函数中传入一个回调函数，在回调函数中我们创建我们想要的界面。

``` rust
pub fn run<F>(self, on_finish_launching: F)
    where
        F: 'static + FnOnce(&mut App),
    {
        let this = self.0.clone();
        let platform = self.0.borrow().platform.clone();
        platform.run(Box::new(move || {
            let cx = &mut *this.borrow_mut();
            on_finish_launching(cx);
        }));
    }
```

现在我们先列出所有的代码，然后逐步分析：

```rust
use gpui::{App, Application, Empty, WindowOptions, prelude::*};

fn main() {
    Application::new().run(|cx: &mut App| {
        let windows_options = WindowOptions::default();
        cx.open_window(windows_options, |_, cx| cx.new(|_| Empty))
            .unwrap();
        cx.activate(true);
    });
}

```

运行这段程序以后，我们就会发现创建了一个除了标题栏外都是透明的一个程序。

现在我们来逐步进行分析：

在 `App::run` 函数中我们需要传入一个函数来绘制我们的界面，这里我们就使用 `App::open_window` 来创建一个普通的窗口，

```rust
pub fn open_window<V: 'static + Render>(
        &mut self,
        options: crate::WindowOptions,
        build_root_view: impl FnOnce(&mut Window, &mut App) -> Entity<V>,
    ) -> anyhow::Result<WindowHandle<V>>{!implemented()}
```

这里我们可以看到 `open_window` 函数需要传入两个函数，一个是 `WindowOptions`, 一个是返回一个 `Entity<V>` 的函数，这里的  `Entity` 是 GPUI 中定义的一个结构体，这个结构体由 `GPUI` 统一管理，至于怎么统一管理，我们暂且不深究。同时 `V` 是需要实现 `Render` 这个 Trait.

这个函数需要返回一个 `Entity<V>` 这个类型的数据，我们查看源代码就可以发现，可以使用 `App:new()` 这个函数来创建一个 `Entity<V>` 这个类型的数据。

```rust
 fn new<T: 'static>(&mut self, build_entity: impl FnOnce(&mut Context<T>) -> T) -> Entity<T> 
```

我们查看代码发现 `Empty` 这个结构体正好实现了 `Render` Trait .这样我们就出现了一个什么也没有的透明的窗口。
